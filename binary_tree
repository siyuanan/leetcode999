# binary tree
class Solution:
    # inorder traversal
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        def helper(root, result): 
            if root == None: 
                return
            helper(root.left, result)
            result.append(root.val)
            helper(root.right, result)
            
        result = []
        helper(root, result)
        return result
        
    # pre-order
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        def helper(root, result): 
            if root == None: 
                return
            result.append(root.val)
            helper(root.left, result)
            helper(root.right, result)
            
        result = []
        helper(root, result)
        return result
        
    # post-order
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        def helper(root, result): 
            if root == None: 
                return
            helper(root.left, result)
            helper(root.right, result)
            result.append(root.val)
            
        result = []
        helper(root, result)
        return result
        
    # 110. Balanced Binary Tree
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        def height(node): 
            # return node height if tree is balanced
            # otherwise -1
            if node == None: 
                return 0
            left = height(node.left)
            if left == -1: 
                return -1
            right = height(node.right)
            if right == -1: 
                return -1
            if abs(left-right) > 1: 
                return -1
            return max(left, right)+1
        return height(root) >= 0
        
    # 101. Symmetric Tree
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        def symmetric(t1, t2): 
            if t1 == None and t2 == None: 
                return True
            elif t1 == None or t2 == None: 
                return False
            elif t1.val != t2.val: 
                return False
            return symmetric(t1.left, t2.right) and symmetric(t1.right, t2.left)
        
        if root == None: 
            return True
        return symmetric(root.left, root.right)
        
    # 951. Flip Equivalent Binary Trees
    def flipEquiv(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:
        if root1 == None and root2 == None: 
            return True
        elif root1 == None or root2 == None: 
            return False
        elif root1.val != root2.val: 
            return False
        return (
            self.flipEquiv(root1.left, root2.left) and self.flipEquiv(root1.right, root2.right)
        ) or (
            self.flipEquiv(root1.left, root2.right) and self.flipEquiv(root1.right, root2.left)
        )
