# binary tree
class Solution:
    # inorder traversal
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        def helper(root, result): 
            if root == None: 
                return
            helper(root.left, result)
            result.append(root.val)
            helper(root.right, result)
            
        result = []
        helper(root, result)
        return result
        
    # pre-order
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        def helper(root, result): 
            if root == None: 
                return
            result.append(root.val)
            helper(root.left, result)
            helper(root.right, result)
            
        result = []
        helper(root, result)
        return result
        
    # post-order
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        def helper(root, result): 
            if root == None: 
                return
            helper(root.left, result)
            helper(root.right, result)
            result.append(root.val)
            
        result = []
        helper(root, result)
        return result
        
    # 110. Balanced Binary Tree
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        def height(node): 
            # return node height if tree is balanced
            # otherwise -1
            if node == None: 
                return 0
            left = height(node.left)
            if left == -1: 
                return -1
            right = height(node.right)
            if right == -1: 
                return -1
            if abs(left-right) > 1: 
                return -1
            return max(left, right)+1
        return height(root) >= 0
